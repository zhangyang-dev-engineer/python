函数简介
    -函数也是一个对象
    -对象是内存中专门用来存储数据的一块区域
    -函数可以用来保存一些可执行的代码，并且可以在需要的时，对这些语句进行多次调用
    -调用函数：函数对象（）
    -定义函数一般都是要实现某种功能的
    -创建函数：
        def 函数名（[形参1，形参2...]):
            代码块
        函数名必须要符合标识符的规范
     fn时函数对象，fn()调用函数   print是函数对象，   print()调用函数   
     
     函数的参数
        在定义函数时，可以在函数名后的（）中定义数量不等的形参，多个形参之间使用，隔开
        形参（形式参数）定义形参就相当于在函数的内部声明了变量，但是并不赋值
        实参（实际参数）：
            如果函数定义时，指定了形参，那么在调用函数时，也必须传递实参，实参将会赋值对应的形参，有几个形参就传几个实参
        定义形参时，可以为形参指定默认值，如果用户指定了默认值，用户传递参数后，默认值没有任何用，如果用户没有传递参数，则默认值生效
       
       实参的传递参数：
          位置参数
              位置参数就是将对应的实参复制给对应位置的形参，第一个实参赋值给第一个形参，第二个实参赋值给第二个形参。。。
              
          关键字参数：可以不按照形参定义的顺序去传递，而直接根据参数名去传递参数  fn(a=1,c=2,a=3)  print('hello',end='')
          位置参数和关键字参数可以混合使用，混合使用关键字和位置参数时，必须将位置参数写到前面
          函数在调用时，解析器不会检查实参的类型，实参可以传递任意类型的对象
          在函数中对形参进行重新赋值，不会影响其它的变量    ，如果形参执行的时一个对象，当我们通过形参去修改对象时，会影响到所有指向该对象的变量
     不定长参数：
          定义函数时，可以在形参前面加上一个*，这样这个形参将会获取到所有的实参，它将会所有的实参保存到一个元组中 
                    *a会接收所有的位置实参，并且将这些实参统一保存到一个元组中（装包）,带*的参数只能有一个，带*的参数，可以和其它参数配合使用
                          第一个参数给a,第二个参数给b，剩下的都保存在c的元组中
                     可变参数不是必须写到最后，但是注意，带*的参数后的所有参数，必须以关键字参数的形式传递，第一个参数给a，剩下的参数给b使用
                     c必须使用关键字参数
                     
                     如果*参数放在开头，所有位置参数都给a,b和c都必须使用关键字参数
                    如果在形参的开头直接写一个*，则要求我们所有的参数必须以关键字参数的形式传参
                    *形参只能接收位置参数，而不能接收关键字参数
                    **形参可以接收其它关键字参数，它会将这些参数统一保存到一个字典中，字典的key就是参数的名字，字典的value就是参数的值  **形参只能有一个                        
                        **形参只能有一个，并且必须写在所有参数的最后
                定义一个函数，可以求任意个数的和
                def sum(*a):
                  result=0
                  for n in a :
                    result+=n
                  print(result)
                  
                  
              参数的解包（拆包）
                传递实参时，也可以在序列类型的参数前添加星号，这样他会自动将序列中的元素依次作为参数传递，要求序列中元素的个数，必须和形参的个数一致
                
                通过**来对一个字典进行解包操作  
                  
            返回值： 返回值就是函数执行以后返回的结果
                可以通过return来指定函数的返回值
                  可以直接使用函数的返回值，也可以通过一个变量接收函数的返回值
                  return 后面跟什么值，函数就会返回什么值
                  return 后面可以跟任意的对象，返回值甚至可以是一个函数
                  如果不写return或者不写return，相当于return None
                  在函数中，return后的代码不会执行，return一旦执行函数,函数自动结束
                  break 用来退出当前循环
                  continue用来跳过单次循环
                  return 结束函数
                  
             help（）是python的内置函数
                通过help（）函数可以查询python的函数用法
                 语法：和老婆（函数对象）
                 help(print)  获取print（）函数的使用说明
             文档字符串：(doc str)
                  在定义函数时，可以在函数的内部编写文档字符串，文档字符串就是函数的说明
                    当我们编写了文档字符串时，就可以通过help()函数来查看函数的说明
                    文档字符串非常简单，其实直接在函数的第一行写一个字符串就是文档字符串
                def fn(a：int,b:bool,c:str='hello')->str
                  ...
                  这是一个文档字符串实例
                  函数作用，函数参数：
                  ...
                  return
              作用域：（scope)
                 作用域指的是变量生效的区域
                 在python 中一共有两种作用域
                    全局作用域
                      -全局作用域在程序执行时创建，在程序执行结束时销毁
                      -所有函数以外的区域都是全局作用域
                      -在全局作用域中定义的变量，都属于全局变量，全局变量可以在程序的任意位置被访问
                    函数作用域
                      -函数作用域在函数调用时创建，在调用结束时销毁
                      -函数每调用一次就会产生一个新的函数作用域
                      -在函数作用域中定义的变量，都是局部变量，它只能在函数内部被访问
                    变量的查找
                        -当我们使用变量时，会优先在当前作用域中寻找该变量，如果有则使用
                          如果没有则继续去上一级作用域中寻找，如果有则使用
                          如果依然没有则继续去上一级作用域寻找，依次类推
                          直到找到全局作用域，依然没有找到，则会抛出异常
                          在函数中为变量赋值时，默认都是为局部变量赋值
                            如果希望在函数内部修改全局变量，则需要使用global关键字，来声明变量
               命令空间：变量存储的位置，每一个变量都需要存储到指定的命名空间中，每一个作用域都会有一个它对应的命名空间
                        全局命名空间，用来保存全局变量，函数命名空间用来保存函数中的变量
                        命名空间实际上就是一个字典，是一个专门用来存储变量的字典
                        
                    locals()用来获取当前作用域的命名空间，如果在全局作用域中调用locals()则获取全局命名空间，如果在函数作用域中调用locals()则获取函数
                        命名空间，返回的是一个字典
                        scope= locals()  当前命名空间，可以通过scope来操作函数的命名空间，但是也是不建议这么做  scope['c']=1000
                    globals()函数可以在任意位置获取全局命名空间    
              递归： 递归就是自己去引用自己
                    递归函数，在函数中自己调用自己
                    无穷递归：如果这个函数被调用，程序内存回溢出，效果类似于死循环
                        它的整体思想是：将一个大问题分解为一个个小问题，直到问题无法分解时，再去解决问题
                    递归式函数的两个条件：
                          1，基线条件：问题可以被分解为最小问题，当满足基线条件时，递归就不执行了
                          2，递归条件：将问题继续分解的条件
                      递归和循环类似，基本是可以互相代替的，
                          循环编写起来比较用以，阅读起来稍难，
                          递归编写起来难，但是方便阅读
    函数式编程                
     在python 中函数是 一等对象
       一等对象一般都会具有如下特点：
          1，对象是在运行是创建的
          2，能赋值给变量或作为数据结构中的元素
          3，能作为参数传递
          4，能作为返回值返回
      高阶函数
          高阶函数至少要符合以下两个特点中的一个
            1，接收一个或多个函数作为参数  函数中保存的代码传到目标函数
            2，将函数作为返回值返回 
        filter()      对元素过滤   
           filter() 可以从序列中过滤除符合条件的元素，保存一个新的序列中
              参数：1，函数，根据该函数来过滤序列（可迭代的结构）
                    2，需要过滤的序列（可迭代的结构）
               返回值：
                过滤后的新序列（可迭代的结构）
     匿名函数  lamba 函数表达式（语法糖） 一般作为参数使用，其他地方一般不会使用
        lambda函数表达式专门用来创建一些简单的函数，它是函数创建的又一种方式
        语法：lambda  参数列表 ：返回值
      也可以将匿名函数赋值给一个变量，一般不会这么做            
           map()    对元素操作
              map()函数可以对可迭代对象中的所有元素做指定的操作，然后将其添加到一个新的对象中返回
      sort()
          该方法用来对列表中的元素进行排序，默认比较列表中的元素的大小
          在sort()可以接收一个关键字参数 key
              key需要一个函数作为参数，当设置了函数作为参数
              每次都会以列表中的一个元素作为参数来调用函数，并且使用函数的返回值来比较元素的大小
            l=['bb','aaa','c']    l.sort(key=len)     
            l=[2,5,'1','4']     l.sort(key=int) 
          sorted()
              这个函数和sort()的用法基本一致，但是sorted()可以对任意序列进行排序
                并且使用sorted()排序不会影响原来的对象，而是返回一个新对象
     将函数作为返回值返回，也是一种高阶函数 这种高阶函数可以称作闭包，通过闭包可以创建一些只有当前函数能访问的变量，可以将一些私有的数据藏到闭包中
          形成闭包的要件：1，函数嵌套，2，将内部函数作为返回值返回  3，内部函数必须要使用到外部函数的变量
 装饰器    
        我们可以直接修改函数中的代码来完成需求，但是会产生以下问题
            1，如果要修改的函数过多，修改起来会比较麻烦
            2，如果不方便后期的维护
            3，并且这样做会违反开闭原则（ocp)   程序的设计，要求开发对程序的扩展，要关闭对程序的修改
        
        传一个旧函数返回一个新函数   
        在定义函数时，可以通过@装饰器，来使用指定的装饰器，来装饰当前的函数，可以同时为一个函数指定多个装饰器  ，这样函数将会按照由内到外执行
                          @包装器先靠近函数的先执行
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
