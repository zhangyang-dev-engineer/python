对象（object）
  什么是对象：
    对象时内存中专门用来存储数据的一块区域
    对象中可以存放各种数据（比如，数字，布尔值，代码）
    对象由三部分组成：
          1，对象的标识，对象的类型，对象的值
          
 面向对象（oop)
    python是一门面向对象的编程语言
    所谓面向对象的语言，简单理解就是语言中的所有操作都是通过对象来进行的
          
 类：（class)
    目前所学的对象都是python内置对象
    但是内置对象并不能满足所有的需求，所以我们在开发中经常需要自定义一些对象
  class MyClass():
      pass
  print(MyClass)
  使用MyClass创建一个对象
  mc=MyClass()  使用类来创建对象，就像调用一个函数一样   mc是Myclass是一个实例
    isinstance（mc,MyClass）用来检查是否是一个类的实例
 类也是一个对象
 类就是一个用来创建对象的对象
 类是type类型，定义类实际上就是定义type类型的对象
 
 使用类创建对象的流程：
      1，创建一个变量
      2,在内存中创建一个新对象
      3，__init__(self)方法执行
      4，将对象的id赋值给变量

      mc = MyClass()  mc就是通过MyClass创建的对象，mc是MyClass的实例
      mc_2=MyClass()  mc  mc_2都是MyClass的实例，他们都是一类对象
      isinstance()用来检查一个对象是否是一个类的实例

      现在我们通过MyClass这个类创建的对象都是一个空对象
      也就是对象中实际上什么都没有，相当于是一个空的盒子
      可以向对象中添加变量，对象中的变量称为属性
      语法：对象.属性名= 属性值
类的定义：
    类和对象都是对现实生活中的内容的和程序中的内容的抽象
    实际上所有的事物都是由两部分构成：
        1，数据（属性）
        2，行为（方法）
   Class Person:
      在类的代码块中，我们可以定义变量和函数
      在类中我们所定义的变量，将会称为所有的实例的公共属性，变量会称为该类实例的公共属性，所有该类实例都已通过对象.属性名的形式访问
                                               
        当我们调用一个对象属性时，解析器会先在当前对象中寻找是否含有该属性
          如果有，则直接访问当前的对象的属性值，如果没有，则去当前的类对象中去寻找，如果有则返回类对象的属性值，如果没有则报错
    类对象和实例对象都可以保存属性（方法）
        如果这个属性（方法）是所有的实例共享的，则应该将其保存到类对象
        如果这个属性（方法），是某
    在类中可以定义一些特殊方法（魔术方法）
    特殊方法都是以__开头，__结尾的方法   特殊方法不需要我们自己调用，不要尝试去调用特殊方法，特殊方法将会在特殊的时刻自动调用
      学习特殊方法：
        1，特殊方法什么时候调用
        2，特殊方法有什么用
    
   类的基本结构：
      class 类名（[父类]):
          公共的属性。。
          对象的初始化方法
          其它方法
        
   封装：面向对象的三大特性之一
      封装指的是对象中一些不希望被外部访问到的属性或方法
      可以为对象的属性使用双下划线开头__xxx
      双下划线开头的属性，是对象的隐藏属性，隐藏属性只能在类的内部访问，无法通过对象访问
      其实隐藏属性只不过是python自动为属性改了一个名字，实际上将名字修改为了，_类名_属性名  比如__name->_Person_name
      使用__开头的属性，实际上依然可以在外部访问，所以这种方式一般不用，一般我们会将一些私有属性（不希望被外部访问的属性），所以这种方式一般不用
          一般情况下，使用_开头的属性都是私有属性，没有特殊需要不要修改私有属性
        
         property装饰器，用来将一个get方法，转换为对象的属性
           添加为property装饰器以后，我们就可以像调用属性一样使用get方法
           使用property装饰方法，必须和属性名一样的
        setter方法的装饰器，@属性名.setter
        
   继承：继承是面向对象三大特性之一
          通过继承我们可以使一个类获取到其它类中的属性和方法
          在定义类时，可以在类名后的括号中指定当前类的父类（超类，基类，super)
              子类（衍生类）可以直接继承父类中所有的属性和方法
         通过继承可以直接让子类获取到父类的方法或属性，避免编写重复的代码，也符合ocp原则，所以我们经常需要同故宫继承来对一个类进行扩展     
          在创建类时，如果省略了父类，则默认父类为object
          object是所有类的父类，所有类都继承object
          issubclass()方法检查一个类是否是另一个类的子类
      
          如果在子类中如果有和父类同名的方法，则通过子类实例去调用方法时
            会调用子类的方法而不是父类的方法，这个特点称之为方法的重写（覆盖  ，override)
             当我们调用一个对象的方法时，会优先去当前对象中寻找是否具有该方法，如果有则直接调用，如果没有，则去当前对象的父类中寻找，如果父类中有
             则直接调用父类的方法，如果没有，则去父类的父类找，依次类推，直到找到object,如果依然没有找到，则报错
         父类中的所有方法都会被子类继承，包括特殊方法
         @property  @属性名.setter  这两个注解，指明get,set方法
          super()可以用来获取当前类的父类，不需要传递self  
           多重继承：
                __bases__这个属性可以获取当前类的的所有父类
                在python中是支持多重继承的，也就是我们可以为一个类同时指定多个父类，可以在类名的（）里面添加多个类，来实现多重继承
                多重继承，会使子类同时拥有多个父类，并且会获取到所有父类的方法
                class c(A,B):
                  pass
        在开发中，没有特殊的情况，应该避免使用多重继承，因为多重继承会让我们代码过于复杂
        多个父类中有同名的方法，会在先在第一个父类中寻找，然后找第二个，然后找第三个。。前面父类的方法会覆盖后面父类方法的

    多态：是面向对象的三大特征之一
          len()之所以一个对象能通过len()方法来获取长度，是因为对象中具有特殊方法__len__，换句话说，只要对象中有__len__特殊方法，
                  就可以通过len()来获取它的长度
        isinstance在开发中一般不用，因为违反多态特征
        
  面向对象三大特征：
        封装：
          -确保对象的数据安全
        继承：
          -保证了对象的可扩展性
        多态:
          -保证了程序的灵活性
        
        类属性，直接在类中定义的属性是类属性
          类属性可以通过类或类的实例访问到
          但是类属性只能通过类对象来修改，无法通过实例对象修改
        实例属性：通过实例对象添加的属性属于实例属性，实例属性只能通过实例对象来访问，类对象无法访问修改
        实例方法：在类中定义，以self 作为第一个参数的方法都是实例方法，实例方法调用时，python会将调用对象作为self传入
                  当通过类调用时，不会自动传递self,此时我们必须手动传递self
        类方法：在类内部使用@classmethod来修饰的方法都属于类方法
                类方法的第一个参数是cls，也会被自动传递，cls就是当前的类对象
                类方法和实例方法的区别： 实例方法的第一个参数是self，而类方法的第一个参数是cls，类方法可以通过类去调用，也可以通过实例调用，没有区别
        静态方法：在类中使用@staticmethiod来修饰的方法属于静态方法
               静态方法不需要指定任何的默认参数，静态方法可以通过类和实例去调用
               静态方法，基本上是一个和当前类无关的方法，它只是一个保存到当前类中的函数
               静态方法一般都是一些工具方法，和当前类无关
              
        
垃圾回收：   
        在程序中没有被引用的对象就是垃圾，这种垃圾对象过多会影响程序的运行性能
        所以我们必须进行及时的垃圾回收，所谓的垃圾回收就是将垃圾对象从内存中删除
        在python中有自动的垃圾回收机制，他会自动将这些没有引用的对象删除，所以我们不用手动处理垃圾回收
        del是一个特殊的方法，他会在对象被垃圾回收前调用
          def __def__(self):
            print()
        
   特殊方法（魔术方法）：
        特殊方法都是使用__开头和结尾的，特殊方法一般不需要我们手动调用，需要在一些特殊情况下自动执行
          当我们打印一个对象时，实际上打印的是对象中的特殊方法__str__()的返回值 
            def __str__(self):
                return xxx
              __str__（）这个特殊方法会在尝试将对象转换为字符串的时候调用，它的作用是可以用来指定对象转换为字符串的结果 （print函数）
              __repr__(self) 这个特殊方法会在当前对象使用repr()函数时调用，它的作用是指定对象在‘交互模式’中直接输出效果
              object，__lt__(self,other) 小于   
                    def __gt__(self,other):
                         return self.age>other.age
              object，__le__(self,other) 小于等于
              object，__eq__(self,other) 等于
              object，__ne__(self,other) 不等于
              object，__gt__(self,other) 大于
              object，__ge__(self,other) 大于等于
              __len()__获取对象的长度
              __bool__  可以通过这个方法定制规则
        
 模块（module):
      模块化，指将完整的程序分解为一个一个的小模块，通过模块组合，来搭建出一个完整的程序，
              不采用模块化，统一将所有台吗编写到一个文件中
              采用模块化，将程序分别编写到多个文件中
          模块化特点：1，方便开发，2，方便维护3，模块可以复用 
      在python中要给py文件就是一个模块，要想创建模块 ，实际上就是创建一个python 文件，注意：模块名的符号标识符的规范 
         在一个模块中引入外部模块,import可以在程序的任意位置调用，但是一般情况下，import语句都会统一写在程序的开头
          在每一个模块内部都有一个__name__属性，通过这个属性可以获取到模块的名字
          1，import 模块名 （模块名，就是python文件的 名字，注意不要py)
              可以引入同一个模块多次，但是模块的实例只会创建一个
          2，import  模块名 as 别名
        也可以只引入模块中的部分内容
          语法： from 模块名 import 变量，变量...
        引入模块中所有内容： from  模块名 import *    一般不会使用
        也可以为引入的变量使用别名  语法：from  模块名 import 变量名 as 别名
        添加了__的变量，只能在模块内部访问，在通过import *引入时，不会引入__开头的变量
        编写测试代码，这部分代码，只要当当前文件作为主模块的时候才需要执行，而当模块被其它模块引入时，不需要执行的，此时我们就必须要检查当前模块是否是主模块
          if __name__ == '__main__':
              测试代码
         
  包：package
      包也是一个模块，当我们一个模块代码过多时，或者一个模块需要被分解为多个模块时，这时就需要使用到包
      普通的模块就是一个py文件，而包是一个文件夹
          包中必须要有一个__init__.py这个文件，这个文件中可以包含有包中的主要内容  from hello import  a,b 
        
        _pycache_是模块的缓存文件  py代码在执行前，需要被解析器先转换为机器码，然后再执行，所以我们在使用模块（包），也需要将模块的代码先转换为
            机器码，然后再交由计算机执行，而为了提高程序运行的性能，python会再编译过一次以后，将代码保存到一个缓存文件中，这样再下次加载这个模块（包）
             时，就可以不再重新编译而时直接加载缓存中编译好的代码即可
        
   开箱即用;
      为了实现开箱即用思想，python中为我们提供了一个模块的标准库，为了这个标准库中，由很多很强大的模块我们直接可以使用，并且标准库在随python的安装一同安装
        sys模块，它里面提供了一些变量和函数，使我们可以获取python解析器的信息，或者通过函数来操作python解析器
            sys.argv 获取该代码时，命令行中所包含的参数，该属性是一个列表，列表中保存了当前命令的所有参数 
            sys.modules 获取当前程序中引入的所有模块，modules是一个字典，字典的key是模块的名字，字典的value是模块的对象
            sys.path   它是一个列表中保存的是模块的搜索路径
            sys.platform 表示python运行的平台
            sys.exit() 函数用来退出程序 
        pprint 模块： 它给我们提供了一个方法pprint()该方法可以用来对打印的数据做简单的格式化
        os模块：让我们可以对操作系统进行访问
              os.environ 通过这个属性可以获取系统的环境变量
              os.system() 可以用来执行操作系统的名字 如os.system('dir')
            
     
     
     
     
     
     
     
     
     
     
     
     
     
     
        
        
